<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PDF to HTML</title>
    <style>
      :root {
        --fg: #111827;
        --muted: #6b7280;
        --bg: #ffffff;
        --border: #e5e7eb;
        --danger: #b91c1c;
      }
      body {
        background: var(--bg);
        color: var(--fg);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        margin: 0;
      }
      .container {
        max-width: 900px;
        margin: 0 auto;
        padding: 24px 16px;
      }
      h1 {
        font-size: 24px;
        margin: 0 0 12px;
      }
      p {
        margin: 8px 0;
      }
      form {
        display: flex;
        gap: 12px;
        align-items: center;
        padding: 12px;
        border: 1px solid var(--border);
        border-radius: 10px;
      }
      input[type="file"] {
        flex: 1;
      }
      button {
        appearance: none;
        border: 1px solid var(--border);
        background: #111827;
        color: #fff;
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
      }
      #result {
        margin-top: 16px;
        padding: 12px;
        border: 1px solid var(--border);
        border-radius: 10px;
      }
      .muted {
        color: var(--muted);
      }
      .error {
        color: var(--danger);
        font-weight: 600;
        white-space: pre-wrap;
        word-wrap: break-word;
      }
      pre.json-output {
        white-space: pre-wrap;
        word-wrap: break-word;
        background: #0b1020;
        color: #e5e7eb;
        padding: 12px;
        border-radius: 8px;
        overflow-x: auto;
        user-select: text;
      }
      .html-output {
        background: #ffffff;
        color: var(--fg);
        border: 1px solid var(--border);
        padding: 12px;
        border-radius: 8px;
        overflow: auto;
      }
      pre.streaming-output {
        max-height: 320px;
        overflow: auto;
      }
      .toolbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      a.link {
        color: var(--fg);
        text-decoration: underline;
      }
    </style>
    <script src="/static/htmx.min.js"></script>
    <script>
      (function () {
        const scrollState = new Map();
        const tolerancePx = 8;

        function getJobElement(elt) {
          if (!(elt instanceof HTMLElement)) return null;
          return elt.closest("[data-job-id]");
        }

        function getStreamingOutput(jobElt) {
          if (!(jobElt instanceof HTMLElement)) return null;
          return jobElt.querySelector('[data-streaming-output="partial"]');
        }

        function getJobId(jobElt) {
          if (!(jobElt instanceof HTMLElement)) return null;
          return jobElt.getAttribute("data-job-id");
        }

        function findJobById(jobId) {
          if (!jobId) return null;
          const selector = `[data-job-id="${jobId}"]`;
          const candidate = document.querySelector(selector);
          return candidate instanceof HTMLElement ? candidate : null;
        }

        function capture(jobElt) {
          const jobId = jobElt.getAttribute("data-job-id");
          if (!jobId) return;
          const pre = getStreamingOutput(jobElt);
          if (!(pre instanceof HTMLElement)) {
            scrollState.delete(jobId);
            return;
          }

          const scrollTop = pre.scrollTop;
          const scrollHeight = pre.scrollHeight;
          const clientHeight = pre.clientHeight;
          const maxScrollTop = Math.max(0, scrollHeight - clientHeight);
          const distanceFromBottom = Math.max(0, scrollHeight - (scrollTop + clientHeight));
          const atBottom = distanceFromBottom <= tolerancePx || scrollTop >= maxScrollTop - tolerancePx;

          scrollState.set(jobId, { atBottom, scrollTop });
        }

        function restore(jobId, fallbackElt) {
          const jobElt = findJobById(jobId) || getJobElement(fallbackElt);
          if (!jobElt) return;
          const pre = getStreamingOutput(jobElt);
          const state = jobId ? scrollState.get(jobId) : null;
          if (!(pre instanceof HTMLElement) || !state) return;

          const maxScrollTop = Math.max(0, pre.scrollHeight - pre.clientHeight);
          if (state.atBottom) {
            pre.scrollTop = maxScrollTop;
            return;
          }
          if (typeof state.scrollTop === "number") {
            pre.scrollTop = Math.min(state.scrollTop, maxScrollTop);
          }
        }

        document.body.addEventListener("htmx:beforeSwap", (event) => {
          const jobElt = getJobElement(event.detail && event.detail.elt);
          if (jobElt && jobElt.matches("[data-job-id]")) {
            capture(jobElt);
          }
        });

        document.body.addEventListener("htmx:afterSwap", (event) => {
          const jobElt = getJobElement(event.detail && event.detail.elt);
          const jobId = getJobId(jobElt);
          if (jobId) {
            restore(jobId, event.detail && event.detail.elt);
          }
        });
      })();
    </script>
  </head>
  <body>
    <main class="container">
      <h1>PDF to HTML</h1>
      <p class="muted">Upload a PDF and wait for HTML conversion to finish.</p>

      <form
        hx-post="/convert"
        hx-target="#result"
        hx-swap="innerHTML"
        enctype="multipart/form-data"
      >
        <input type="file" name="file" accept="application/pdf,.pdf" required />
        <button type="submit">Convert</button>
      </form>

      <section id="result">{% include "_result.html" %}</section>
    </main>
  </body>
</html>
